{"ast":null,"code":"import { db } from './firebase';\nimport { collection, addDoc, query, where, getDocs, doc, updateDoc, orderBy, limit } from 'firebase/firestore';\nimport { analyticsService } from './analytics';\nclass SubscriptionService {\n  async createSubscription(subscriptionData) {\n    try {\n      const docRef = await addDoc(collection(db, 'subscriptions'), {\n        ...subscriptionData,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString()\n      });\n\n      // Track subscription creation\n      await analyticsService.trackEvent('subscription_created', {\n        tier: subscriptionData.tier,\n        price: subscriptionData.price,\n        userId: subscriptionData.userId\n      });\n      return {\n        id: docRef.id,\n        ...subscriptionData\n      };\n    } catch (error) {\n      console.error('Error creating subscription:', error);\n      throw error;\n    }\n  }\n  async getUserSubscriptions(userId) {\n    try {\n      const q = query(collection(db, 'subscriptions'), where('userId', '==', userId), orderBy('createdAt', 'desc'));\n      const querySnapshot = await getDocs(q);\n      return querySnapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n    } catch (error) {\n      console.error('Error fetching user subscriptions:', error);\n      throw error;\n    }\n  }\n  async getActiveSubscription(userId) {\n    try {\n      const q = query(collection(db, 'subscriptions'), where('userId', '==', userId), where('status', '==', 'active'), orderBy('createdAt', 'desc'), limit(1));\n      const querySnapshot = await getDocs(q);\n      if (querySnapshot.empty) {\n        return null;\n      }\n      const doc = querySnapshot.docs[0];\n      return {\n        id: doc.id,\n        ...doc.data()\n      };\n    } catch (error) {\n      console.error('Error fetching active subscription:', error);\n      throw error;\n    }\n  }\n  async cancelSubscription(subscriptionId) {\n    try {\n      const subscriptionRef = doc(db, 'subscriptions', subscriptionId);\n      await updateDoc(subscriptionRef, {\n        status: 'cancelled',\n        cancelledAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString()\n      });\n\n      // Track subscription cancellation\n      await analyticsService.trackEvent('subscription_cancelled', {\n        subscriptionId: subscriptionId\n      });\n      return true;\n    } catch (error) {\n      console.error('Error cancelling subscription:', error);\n      throw error;\n    }\n  }\n  async updateSubscriptionStatus(subscriptionId, status) {\n    try {\n      const subscriptionRef = doc(db, 'subscriptions', subscriptionId);\n      await updateDoc(subscriptionRef, {\n        status: status,\n        updatedAt: new Date().toISOString()\n      });\n      return true;\n    } catch (error) {\n      console.error('Error updating subscription status:', error);\n      throw error;\n    }\n  }\n}\nexport const subscriptionService = new SubscriptionService();","map":{"version":3,"names":["db","collection","addDoc","query","where","getDocs","doc","updateDoc","orderBy","limit","analyticsService","SubscriptionService","createSubscription","subscriptionData","docRef","createdAt","Date","toISOString","updatedAt","trackEvent","tier","price","userId","id","error","console","getUserSubscriptions","q","querySnapshot","docs","map","data","getActiveSubscription","empty","cancelSubscription","subscriptionId","subscriptionRef","status","cancelledAt","updateSubscriptionStatus","subscriptionService"],"sources":["/Users/prakash/Documents/vibe-coding/src/services/subscriptions.js"],"sourcesContent":["import { db } from './firebase';\nimport { collection, addDoc, query, where, getDocs, doc, updateDoc, orderBy, limit } from 'firebase/firestore';\nimport { analyticsService } from './analytics';\n\nclass SubscriptionService {\n  async createSubscription(subscriptionData) {\n    try {\n      const docRef = await addDoc(collection(db, 'subscriptions'), {\n        ...subscriptionData,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString()\n      });\n\n      // Track subscription creation\n      await analyticsService.trackEvent('subscription_created', {\n        tier: subscriptionData.tier,\n        price: subscriptionData.price,\n        userId: subscriptionData.userId\n      });\n\n      return { id: docRef.id, ...subscriptionData };\n    } catch (error) {\n      console.error('Error creating subscription:', error);\n      throw error;\n    }\n  }\n\n  async getUserSubscriptions(userId) {\n    try {\n      const q = query(\n        collection(db, 'subscriptions'),\n        where('userId', '==', userId),\n        orderBy('createdAt', 'desc')\n      );\n      \n      const querySnapshot = await getDocs(q);\n      return querySnapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      }));\n    } catch (error) {\n      console.error('Error fetching user subscriptions:', error);\n      throw error;\n    }\n  }\n\n  async getActiveSubscription(userId) {\n    try {\n      const q = query(\n        collection(db, 'subscriptions'),\n        where('userId', '==', userId),\n        where('status', '==', 'active'),\n        orderBy('createdAt', 'desc'),\n        limit(1)\n      );\n      \n      const querySnapshot = await getDocs(q);\n      if (querySnapshot.empty) {\n        return null;\n      }\n      \n      const doc = querySnapshot.docs[0];\n      return { id: doc.id, ...doc.data() };\n    } catch (error) {\n      console.error('Error fetching active subscription:', error);\n      throw error;\n    }\n  }\n\n  async cancelSubscription(subscriptionId) {\n    try {\n      const subscriptionRef = doc(db, 'subscriptions', subscriptionId);\n      await updateDoc(subscriptionRef, {\n        status: 'cancelled',\n        cancelledAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString()\n      });\n\n      // Track subscription cancellation\n      await analyticsService.trackEvent('subscription_cancelled', {\n        subscriptionId: subscriptionId\n      });\n\n      return true;\n    } catch (error) {\n      console.error('Error cancelling subscription:', error);\n      throw error;\n    }\n  }\n\n  async updateSubscriptionStatus(subscriptionId, status) {\n    try {\n      const subscriptionRef = doc(db, 'subscriptions', subscriptionId);\n      await updateDoc(subscriptionRef, {\n        status: status,\n        updatedAt: new Date().toISOString()\n      });\n\n      return true;\n    } catch (error) {\n      console.error('Error updating subscription status:', error);\n      throw error;\n    }\n  }\n}\n\nexport const subscriptionService = new SubscriptionService();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}